## 正则表达式 

### 正则表达式工具
* [正则表达式工具](https://regexper.com/)
* [正则表达式工具GitHub](https://github.com/javallone/regexper-static)

### RegExp对象
* 字面量
```
// 语法： const reg = /patterns/flag;
// 匹配单词 is
const reg = /\bis\b/g;
```
* 构造函数
```
// 语法：const reg = new RegExp();需要双重转义
// 转义字符(\) 在JS中是特殊字符，也需要用 \ 转义
const reg = new RegExp('\\bis\\b','g');
```

### 修饰符
* `g`: global全文搜索，不添加，搜索到第一个匹配停止
* `i`: ignore case 忽略大小写，默认大小写敏感
* `m`: multiple lines 多行搜索

### 元字符
* 正则表达式由两种字符类型组成：
  - 原义文本字符（abc）
  - 元字符（\b）
* 元字符是在正则表达式中有特殊含义的非字母字符
* `* + ？ ^ $ . | \ ( ) { } [ ]`

### 字符类
* 我们可以使用元字符 `[ ]` 来创建一个简单的类
* 所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符
* 表达式[abc]把字符a或b或c归为一类，表达式可以匹配这类的字符

### 字符类取反
* 使用元字符 `^` 创建反向类/负向类
* 反向类的意思是不属于某类的内容
* 表达式 `[^abc]`表示 不是字符a或b或c的内容

### 范围类
* `[a-z]`表示从a到z的任意字符，这是个闭区间，也就是包含a和z本身
* 同时范围类内包含字符 `-` ：如 `[0-9-]` 
* "2012-08-08".replace(/[0-9-]/,'');

### 预定义类（匹配常见的字符类）
|字符|等价类|含义|
|:---|:---|:---|
|.|[^\r\n]|除了回车符和换行符之外的所有字符|
|\d|[0-9]|数字字符|
|\D|[^0-9]|非数字字符|
|\s|[\t\n\xOB\f\r]|空白符|
|\S|[^\t\n\xOB\f\r]|非空白符|
|\w|[a-zA-Z_0-9]|单词字符(字母、数字、下划线)|
|\W|[^a-zA-Z_0-9]|非单词字符|

### 边界字符
|字符|含义|
|:---|:---|
|^|以xxx开始|
|$|以xxx结束|
|\b|单词边界|
|\B|非单词边界|

### 量词
|字符|含义|
|:---|:---|
|?|出现0或1次（最多1次）|
|+|出现1或多次（至少1次）|
|*|出现0或多次（任意次）|
|{n}|出现n次|
|{n,m}|出现n到m次|
|{n,}|至少出现n次|
|{0,m}|至多出现m次|

### 贪婪模式
* 正则表达式尽可能多的匹配
* 量词默认是贪婪模式
* '12345678'.replace(/\d{3,6}?/,'X')
* "X78"

### 非贪婪模式
* 正则表达式尽可能少的匹配
* 量词后加上 `?` 是非贪婪模式
* '12345678'.replace(/\d{3,6}?/,'X')
* "X45678"

### 分组
#### 分组-量词
* 使用 `( )` 可以达到分组的功能，使量词作用于分组
* 'a1b2c3d4'.replace(/([a-zA-Z]\d){3}/g,'X')
* 'Xd4'

####  分组-或
* `|` 表示或者
* 'abcdef'.replace(/abc|def/g,'X')
* 'XX'
* 'abcfabdf'.replace(/ab(c|d)f/g,'X')
* 'XX'

#### 分组-反向引用（$1、$2、$3...）
* '2019-09-10'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2/$3/$1')
* "09/10/2019"

#### 忽略分组
* 不希望捕获某些分组，只需要在分组内前面加上 `?:` 就可以
* 'abcdef'.replace(/(ab)(?:cd)(ef)/g,'$1-$2-$3')
* "ab-ef-$3"

### 前瞻
* 正则表达式从文本头部向尾部开始解析，文本尾部方向，成为 前
* 前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言，
* 后顾/后瞻方向相反
* JS 不支持后顾
* 符合不符合特定断言成为 `肯定/正向`匹配 和`否定/负向`匹配
* 'a1b2c3'.replace(/\w(?=\d)/g,'X')
* "X1X2X3"
* 'a1b2c3'.replace(/\w(?!\d)/g,'X')
* "aXbXcX"

|名称|正则|含义|
|:-|:-|:-|
|正向前瞻|exp(?=assert)| |
|负向前瞻|exp(?!assert)| |
|正向后顾|exp(?<=assert)| JS不支持|
|负向后顾|exp(?<!assert)| JS不支持|

### 正则对象属性
* `global`：是否全文搜索，默认false
* `ignore case`：是否大小写敏感，默认是false
* `multiline`：多行搜索，默认值是false
* `lastIndex`：当前表达式匹配内容的最后一个字符的下一个位置（表示执行下一次匹配时的起始位置。）（只在全局作用下有用）
* `source`：正则表达式的文本字符串(不包括标志位)

### 正则对象方法
* RegExp.prototype.test(str)
* 用于测试字符串参数中是否存在匹配正则表达式模式的字符串
* 如果存在则返回`true`，否则返回`false`
  ```
  const reg1 = /\w/;
  const reg2 = /\w/g;
  reg1.test('a') // true
  reg2.test('b') // true | false
  while(reg2.test('b')){
    console.log(reg2.lastIndex)
  }
  ```

* RegExp.prototype.exec(str)
* 使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果
* 如果没有匹配的文本就返回`null`，否则就返回一个结果数组
  - `index`声明匹配文本的第一个字符的位置
  - `input`存放被检索的字符串`string`
* 非全局调用：
* 调用非全局的RegExp对象的exec（）时，返回数组
* 第一个元素是与正则表达式相匹配的文本
* 第二个元素是与RegExpObject的第一个子表达式（分组）相匹配的文本(如果有的话)
* 第三个元素是与RegExp对象的第二个子表达式（分组）相匹配的文本(如果有的话)
* 以此类推

### 字符串对象方法
#### stringl.protatype.search(reg)
* search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串
* 方法返回第一个匹配结果index，查找不到返回-1
* search（）方法不执行全局匹配，它将忽略标志g，并且总是从字符串开始进行检索

#### string.prototype.match(reg)
* match（）方法将检索字符串，以找到一个或多个与regexp匹配的文本
* regexp是否具有标志g对结果影响很大
* 非全局调用：如果regexp没有标志g，那么match（）方法就只能在字符串中执行一次匹配，没找到任何匹配文本将返回null，否则将返回一个数组，
*其中存放了与它找到的匹配文本有关的信息：返回数组的第一个元素存放的是匹配文本，而其余元素存放的是与正则表达式的子表达式匹配的文本。
* 除了常规数组元素之外，返回的数组还含有2个对象属性：
  - `index`声明匹配文本的起始字符在字符串的位置；
  - `input`声明对`stringobject`的引用
* 全局调用：如果regexp具有标志g则match（）方法将执行全局检索，找到字符串中的所有匹配子字符串：没有找到任何匹配的子穿，则返回null，否则返回一个数组，数组元素中存放的是字符串中所有匹配子串，而且也没有index属性或input属性

#### string.prototype.replace(reg,function)
* function的参数
  1. 匹配到的字符串
  2. 分组匹配到的内容（如果有的话）
  3. 匹配到的字符串的index
  4. 原始字符串

  ```
  'a2b2c3d4e5'.replace(/\d/g,function(match,index,origin){
    console.log(index);
    return parseInt(match) + 1;
  })

  'a2b2c3d4e5'.replace(/(\d)(\w)(\d)/g,function(match,group1,group2,group3,index,origin){
    console.log(index);
    return group1 + group3;
  })
  ```